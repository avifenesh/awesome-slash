#!/usr/bin/env node
/**
 * Generate Platform Adapters from Canonical Plugin Definitions
 *
 * Reads plugin source files and generates adapter files for OpenCode and
 * Codex platforms. The generated files are committed to the repo so that
 * install scripts can reference pre-built adapters instead of transforming
 * at install time.
 *
 * Usage:
 *   node scripts/gen-adapters.js           Write generated adapter files
 *   node scripts/gen-adapters.js --check   Validate freshness (exit 1 if stale)
 *   node scripts/gen-adapters.js --dry-run Show what would change without writing
 *
 * Exit codes:
 *   0 - Success (or up-to-date in --check mode)
 *   1 - Stale adapters detected (--check mode) or write error
 *
 * @author Avi Fenesh
 * @license MIT
 */

const fs = require('fs');
const path = require('path');
const discovery = require(path.join(__dirname, '..', 'lib', 'discovery'));
const transforms = require(path.join(__dirname, '..', 'lib', 'adapter-transforms'));

const ROOT_DIR = path.join(__dirname, '..');
const ADAPTERS_DIR = path.join(ROOT_DIR, 'adapters');

// Auto-generated header for all adapter files
const GENERATED_HEADER = '<!-- AUTO-GENERATED by scripts/gen-adapters.js - DO NOT EDIT -->\n';

// Codex uses a placeholder since it doesn't have runtime PLUGIN_ROOT
const CODEX_PLUGIN_ROOT_PLACEHOLDER = '{{PLUGIN_INSTALL_PATH}}';

// ---------------------------------------------------------------------------
// Adapter computation
// ---------------------------------------------------------------------------

/**
 * Core generation logic. Discovers plugins and generates all adapter content
 * in-memory. Returns a map of relative output paths to generated content,
 * plus staleness information.
 *
 * @returns {{ files: Map<string, string>, staleFiles: string[] }}
 *   files: map of relative path (from repo root) -> generated content
 *   staleFiles: relative paths where generated content differs from disk
 */
function computeAdapters() {
  discovery.invalidateCache();

  const files = new Map();

  const plugins = discovery.discoverPlugins(ROOT_DIR);
  const commandMappings = discovery.getCommandMappings(ROOT_DIR);
  const codexSkillMappings = discovery.getCodexSkillMappings(ROOT_DIR);

  // --- OpenCode commands ---
  for (const [target, plugin, source] of commandMappings) {
    const srcPath = path.join(ROOT_DIR, 'plugins', plugin, 'commands', source);
    if (!fs.existsSync(srcPath)) continue;

    let content = fs.readFileSync(srcPath, 'utf8');
    content = transforms.transformBodyForOpenCode(content, ROOT_DIR);
    content = transforms.transformCommandFrontmatterForOpenCode(content);

    const relPath = path.join('adapters', 'opencode', 'commands', target);
    files.set(relPath, GENERATED_HEADER + content);
  }

  // --- OpenCode agents ---
  for (const pluginName of plugins) {
    const srcAgentsDir = path.join(ROOT_DIR, 'plugins', pluginName, 'agents');
    if (!fs.existsSync(srcAgentsDir)) continue;

    const agentFiles = fs.readdirSync(srcAgentsDir).filter(f => f.endsWith('.md'));
    for (const agentFile of agentFiles) {
      const srcPath = path.join(srcAgentsDir, agentFile);
      let content = fs.readFileSync(srcPath, 'utf8');

      content = transforms.transformBodyForOpenCode(content, ROOT_DIR);
      content = transforms.transformAgentFrontmatterForOpenCode(content, { stripModels: true });

      const relPath = path.join('adapters', 'opencode', 'agents', agentFile);
      files.set(relPath, GENERATED_HEADER + content);
    }
  }

  // --- OpenCode skills ---
  for (const pluginName of plugins) {
    const srcSkillsDir = path.join(ROOT_DIR, 'plugins', pluginName, 'skills');
    if (!fs.existsSync(srcSkillsDir)) continue;

    const skillDirs = fs.readdirSync(srcSkillsDir, { withFileTypes: true })
      .filter(d => d.isDirectory());
    for (const skillDir of skillDirs) {
      const skillName = skillDir.name;
      const srcSkillPath = path.join(srcSkillsDir, skillName, 'SKILL.md');
      if (!fs.existsSync(srcSkillPath)) continue;

      let content = fs.readFileSync(srcSkillPath, 'utf8');
      content = transforms.transformSkillBodyForOpenCode(content, ROOT_DIR);

      const relPath = path.join('adapters', 'opencode', 'skills', skillName, 'SKILL.md');
      files.set(relPath, GENERATED_HEADER + content);
    }
  }

  // --- Codex skills ---
  for (const [skillName, plugin, sourceFile, description] of codexSkillMappings) {
    const srcPath = path.join(ROOT_DIR, 'plugins', plugin, 'commands', sourceFile);
    if (!fs.existsSync(srcPath)) continue;

    let content = fs.readFileSync(srcPath, 'utf8');
    content = transforms.transformForCodex(content, {
      skillName,
      description,
      pluginInstallPath: CODEX_PLUGIN_ROOT_PLACEHOLDER
    });

    const relPath = path.join('adapters', 'codex', 'skills', skillName, 'SKILL.md');
    files.set(relPath, GENERATED_HEADER + content);
  }

  // --- Determine which files are stale ---
  const staleFiles = [];
  for (const [relPath, newContent] of files) {
    const absPath = path.join(ROOT_DIR, relPath);
    if (!fs.existsSync(absPath)) {
      staleFiles.push(relPath);
      continue;
    }
    const current = fs.readFileSync(absPath, 'utf8');
    if (current !== newContent) {
      staleFiles.push(relPath);
    }
  }

  return { files, staleFiles };
}

// ---------------------------------------------------------------------------
// Main orchestrator
// ---------------------------------------------------------------------------

/**
 * Run adapter generation. Returns result object or exit code (--check mode).
 *
 * @param {string[]} args - CLI arguments
 * @returns {{ changed: boolean, files: string[] } | number}
 */
function main(args) {
  args = args || [];
  const checkMode = args.includes('--check');
  const dryRun = args.includes('--dry-run');

  const { files, staleFiles } = computeAdapters();

  if (checkMode) {
    if (staleFiles.length > 0) {
      console.log(`[ERROR] Stale adapters detected in ${staleFiles.length} file(s):`);
      for (const f of staleFiles) {
        console.log(`  - ${f}`);
      }
      console.log('\nRun: node scripts/gen-adapters.js');
      return 1;
    }
    return 0;
  }

  if (!dryRun) {
    console.log(`[OK] Generating adapters: ${files.size} files across OpenCode and Codex`);
  }

  const changedFiles = [];

  for (const [relPath, content] of files) {
    const absPath = path.join(ROOT_DIR, relPath);
    const dir = path.dirname(absPath);

    // Check if file needs updating
    let needsUpdate = true;
    if (fs.existsSync(absPath)) {
      const current = fs.readFileSync(absPath, 'utf8');
      if (current === content) {
        needsUpdate = false;
      }
    }

    if (needsUpdate) {
      changedFiles.push(relPath);

      if (dryRun) {
        console.log(`[CHANGE] Would write: ${relPath}`);
      } else {
        fs.mkdirSync(dir, { recursive: true });
        fs.writeFileSync(absPath, content, 'utf8');
      }
    }
  }

  if (!dryRun) {
    if (changedFiles.length > 0) {
      console.log(`[OK] ${changedFiles.length} file(s) updated`);
      for (const f of changedFiles) {
        console.log(`  - ${f}`);
      }
    } else {
      console.log('[OK] All adapters up to date');
    }
  }

  return { changed: changedFiles.length > 0, files: changedFiles };
}

// ---------------------------------------------------------------------------
// Freshness check (for preflight integration)
// ---------------------------------------------------------------------------

/**
 * Check if generated adapters are fresh. For preflight integration.
 *
 * @returns {{ status: string, message: string, staleFiles: string[] }}
 */
function checkFreshness() {
  const { staleFiles } = computeAdapters();

  if (staleFiles.length === 0) {
    return {
      status: 'fresh',
      message: 'All generated adapters are up to date',
      staleFiles: []
    };
  }

  return {
    status: 'stale',
    message: `${staleFiles.length} adapter file(s) are stale`,
    staleFiles
  };
}

// ---------------------------------------------------------------------------
// CLI entry point
// ---------------------------------------------------------------------------

if (require.main === module) {
  const args = process.argv.slice(2);
  const result = main(args);

  // In --check mode, main returns an exit code number
  if (typeof result === 'number') {
    process.exit(result);
  }
}

module.exports = { main, checkFreshness, computeAdapters, GENERATED_HEADER };
